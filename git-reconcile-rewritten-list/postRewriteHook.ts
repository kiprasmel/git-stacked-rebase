import fs from "fs";
import path from "path";

export type SetupPostRewriteHookForOpts = {
	/**
	 * will be used to install the hook,
	 * but will not be used inside the hook itself.
	 */
	dotGitDirPathForInstallingTheHook: string;

	rewrittenListOutputDirPathThatWillBeInsideDotGitDir?: string;
};

export type SetupPostRewriteHookForRet = {
	pathToPostRewriteScript: string;
};

export function setupPostRewriteHookFor(
	hookFileSuffix: string, //
	{
		dotGitDirPathForInstallingTheHook,
		rewrittenListOutputDirPathThatWillBeInsideDotGitDir = "reconcile-rewritten-list",
	}: SetupPostRewriteHookForOpts
): SetupPostRewriteHookForRet {
	setupHookWrapper("post-rewrite", dotGitDirPathForInstallingTheHook);

	const hooksDir: string = path.join(dotGitDirPathForInstallingTheHook, "hooks");
	const pathToPostRewriteScript: string = path.join(hooksDir, "post-rewrite." + hookFileSuffix);

	/**
	 * goal is to save the rewritten-list file,
	 * which git deletes once the rebase is done,
	 *
	 * and when git-stacked-rebase gets called again
	 * with `--apply` or whatever - to recover the commits.
	 *
	 */

	const needle = "NEEDLE__GIT_RECONCILE_REWRITTEN_LIST";
	const oldNeedles: string[] = [
		"NEEDLE__GIT_STACKED_REBASE", //
	];

	const postRewriteScript: string = `\
#!/bin/sh

# DO NOT EDIT THIS FILE MANUALLY
# AUTO-GENERATED BY GIT-STACKED-REBASE

# ${needle}

DOT_GIT_DIR="$(git rev-parse --absolute-git-dir)"
REGULAR_REWRITTEN_LIST_BACKUP_DIR_PATH="$DOT_GIT_DIR/${rewrittenListOutputDirPathThatWillBeInsideDotGitDir}"
REWRITTEN_LIST_BACKUP_FILE_PATH="$REGULAR_REWRITTEN_LIST_BACKUP_DIR_PATH/rewritten-list"

mkdir -p "$REGULAR_REWRITTEN_LIST_BACKUP_DIR_PATH"

cat >> "$REWRITTEN_LIST_BACKUP_FILE_PATH" <<EOF
$1
$(cat /dev/stdin)

EOF

# note that the this format of the message matters
# because we later decode it in 'combineRewrittenLists'.

`;

	const isSafeToOverride = checkIfSafeToOverride({ filepath: pathToPostRewriteScript, needle, oldNeedles });
	if (!isSafeToOverride) {
		/**
		 * except if:
		 * - the needle was manually changed/removed
		 * - the needle was never there in the first place
		 */

		const prefix = "git-reconcile-rewritten-list" as const;
		const msg = `\n${prefix}: post-rewrite hook cannot be installed because another one is installed, but it is not from us.\n\n`;
		throw new Error(msg);
	}

	fs.writeFileSync(pathToPostRewriteScript, postRewriteScript, { mode: "777" });

	return {
		pathToPostRewriteScript, //
	};
}

/**
 * installs a "wrapper" hook that will allow the user
 * to have as many scripts for the hook as needed:
 *
 * the user just needs to create more scripts
 * with the "<hook-name>.<purpose>" filename format,
 * e.g. `post-rewrite.git-stacked-rebase`
 *
 */
export function setupHookWrapper(hookName: string, dotGitDirPath: string): void {
	const needle = "NEEDLE__WRAPPER_HOOK";
	const oldNeedles: string[] = [
		"__ADDED_BY_GIT_STACKED_REBASE", //
	];
	const version = 1;

	const scriptContent = `\
#!/bin/sh

# DO NOT EDIT THIS FILE MANUALLY
# AUTO-GENERATED BY GIT-STACKED-REBASE

# ${needle} ${version}

DOT_GIT_DIR="$(git rev-parse --absolute-git-dir)"
HOOKS_DIR="$DOT_GIT_DIR/hooks"
SCRIPTS="$(find "$HOOKS_DIR" -name "${hookName}.*")"

# if 0 scripts,
# should not read stdin
[ -z "$SCRIPTS" ] && {
	exit 0
}

STDIN="$(cat /dev/stdin)"

for script in $SCRIPTS; do
	printf "$STDIN" | sh "$script" $*
done`;

	const hooksDir: string = path.join(dotGitDirPath, "hooks");
	const pathToHookScript: string = path.join(hooksDir, hookName);

	fs.mkdirSync(hooksDir, { recursive: true });

	/**
	 * prerequisite:
	 * if a user has an existing custom post-rewrite script,
	 * rename it to a different name, so that:
	 * 1. we can use the `post-rewrite` filename for ourselves,
	 * 2. the custom, now renamed, script, will still be called by us.
	 */
	renameCustomScriptIfExists(pathToHookScript, needle, oldNeedles);

	fs.writeFileSync(pathToHookScript, scriptContent, { mode: "777" });
}

function renameCustomScriptIfExists(pathToHookScript: string, needle: string, oldNeedles: string[] = []): void {
	const isSafeToOverride = checkIfSafeToOverride({ filepath: pathToHookScript, needle, oldNeedles });
	if (!isSafeToOverride) {
		const newPath = pathToHookScript + ".custom." + Math.random();
		fs.renameSync(pathToHookScript, newPath);

		const filename = path.basename(newPath);
		const msg = `\ninfo: moved custom "post-rewrite" script into "${filename}", will still be called.\n\n`;
		process.stdout.write(msg);
	}
}

function checkIfSafeToOverride(opts: {
	filepath: string; //
	needle: string;
	oldNeedles?: string[];
}): boolean {
	const fileExists = fs.existsSync(opts.filepath);

	if (!fileExists) {
		return true;
	}

	const fileContent = fs.readFileSync(opts.filepath, { encoding: "utf-8" });
	const fileExistsWithoutNeedles: boolean =
		!fileContent.includes(opts.needle) &&
		!(opts.oldNeedles || []).some((oldNeedle) => fileContent.includes(oldNeedle));

	return !fileExistsWithoutNeedles;
}
